
SupportBoardV100.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ec  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000001d  00800100  00800100  00000660  2**0
                  ALLOC
  2 .debug_aranges 00000100  00000000  00000000  00000660  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000002d3  00000000  00000000  00000760  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000b4a  00000000  00000000  00000a33  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000644  00000000  00000000  0000157d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000b8a  00000000  00000000  00001bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000280  00000000  00000000  0000274c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000312  00000000  00000000  000029cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000230  00000000  00000000  00002cde  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000048  00000000  00000000  00002f0e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 45 01 	jmp	0x28a	; 0x28a <__vector_2>
   c:	0c 94 48 00 	jmp	0x90	; 0x90 <__vector_3>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__vector_18>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	ad 31       	cpi	r26, 0x1D	; 29
  80:	b1 07       	cpc	r27, r17
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 9b 00 	call	0x136	; 0x136 <main>
  88:	0c 94 f4 02 	jmp	0x5e8	; 0x5e8 <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <__vector_3>:
	sei(); //Enable Interrupts
}

/* Gyro and Accelerometer Interrupt */
ISR (PCINT0_vect)
{	
  90:	1f 92       	push	r1
  92:	0f 92       	push	r0
  94:	0f b6       	in	r0, 0x3f	; 63
  96:	0f 92       	push	r0
  98:	11 24       	eor	r1, r1
  9a:	2f 93       	push	r18
  9c:	3f 93       	push	r19
  9e:	4f 93       	push	r20
  a0:	5f 93       	push	r21
  a2:	6f 93       	push	r22
  a4:	7f 93       	push	r23
  a6:	8f 93       	push	r24
  a8:	9f 93       	push	r25
  aa:	af 93       	push	r26
  ac:	bf 93       	push	r27
  ae:	ef 93       	push	r30
  b0:	ff 93       	push	r31
	/* Take Action Based on Source of Interrupt*/ 
	switch(PINB & 0x03)
  b2:	83 b1       	in	r24, 0x03	; 3
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	83 70       	andi	r24, 0x03	; 3
  b8:	90 70       	andi	r25, 0x00	; 0
  ba:	82 30       	cpi	r24, 0x02	; 2
  bc:	91 05       	cpc	r25, r1
  be:	99 f0       	breq	.+38     	; 0xe6 <__vector_3+0x56>
  c0:	83 30       	cpi	r24, 0x03	; 3
  c2:	91 05       	cpc	r25, r1
  c4:	61 f0       	breq	.+24     	; 0xde <__vector_3+0x4e>
  c6:	01 97       	sbiw	r24, 0x01	; 1
  c8:	91 f4       	brne	.+36     	; 0xee <__vector_3+0x5e>
	{
		case (0x01): //Read Gyro
		gyro_read(&Gyro_Raw[0]);
  ca:	83 e1       	ldi	r24, 0x13	; 19
  cc:	91 e0       	ldi	r25, 0x01	; 1
  ce:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <gyro_read>
		uart_write2(adc_read(2));
  d2:	82 e0       	ldi	r24, 0x02	; 2
  d4:	0e 94 03 01 	call	0x206	; 0x206 <adc_read>
  d8:	0e 94 cb 00 	call	0x196	; 0x196 <uart_write2>
  dc:	08 c0       	rjmp	.+16     	; 0xee <__vector_3+0x5e>
		case (0x02): //Read Accel
		accel_read(&Accel_Raw[0]);
		break;

		case (0x03): //Read Gyro + Accel
		gyro_read(&Gyro_Raw[0]);		
  de:	83 e1       	ldi	r24, 0x13	; 19
  e0:	91 e0       	ldi	r25, 0x01	; 1
  e2:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <gyro_read>
		accel_read(&Accel_Raw[0]);
  e6:	81 e0       	ldi	r24, 0x01	; 1
  e8:	91 e0       	ldi	r25, 0x01	; 1
  ea:	0e 94 bf 01 	call	0x37e	; 0x37e <accel_read>
		break;

		default:
		break;
	}
}
  ee:	ff 91       	pop	r31
  f0:	ef 91       	pop	r30
  f2:	bf 91       	pop	r27
  f4:	af 91       	pop	r26
  f6:	9f 91       	pop	r25
  f8:	8f 91       	pop	r24
  fa:	7f 91       	pop	r23
  fc:	6f 91       	pop	r22
  fe:	5f 91       	pop	r21
 100:	4f 91       	pop	r20
 102:	3f 91       	pop	r19
 104:	2f 91       	pop	r18
 106:	0f 90       	pop	r0
 108:	0f be       	out	0x3f, r0	; 63
 10a:	0f 90       	pop	r0
 10c:	1f 90       	pop	r1
 10e:	18 95       	reti

00000110 <initialize>:
void initialize(void)
{
	/* Initialize Required Systems */
	
	/* Comunication */
	uart_init();
 110:	0e 94 b0 00 	call	0x160	; 0x160 <uart_init>
	spi_init(); 
 114:	0e 94 1a 01 	call	0x234	; 0x234 <spi_init>
	i2c_init();
 118:	0e 94 48 02 	call	0x490	; 0x490 <i2c_init>

	/* Sensors */
	gyro_init();
 11c:	0e 94 a1 01 	call	0x342	; 0x342 <gyro_init>
	accel_init();
 120:	0e 94 78 01 	call	0x2f0	; 0x2f0 <accel_init>
	adc_init();
 124:	0e 94 ff 00 	call	0x1fe	; 0x1fe <adc_init>
	
	/* Other */
	wdt_init(SCALLER); // Initializes WDT at 0.25 seconds
 128:	84 e0       	ldi	r24, 0x04	; 4
 12a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <wdt_init>
	interrupt_init();
 12e:	0e 94 cd 02 	call	0x59a	; 0x59a <interrupt_init>
	sei(); //Enable Interrupts
 132:	78 94       	sei
}
 134:	08 95       	ret

00000136 <main>:
/* Declare Used Headers */
#include "main.h"

int main(void)
{	
	initialize(); //Turns on all required Peripherals
 136:	0e 94 88 00 	call	0x110	; 0x110 <initialize>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 13a:	80 e4       	ldi	r24, 0x40	; 64
 13c:	9c e9       	ldi	r25, 0x9C	; 156
 13e:	01 97       	sbiw	r24, 0x01	; 1
 140:	f1 f7       	brne	.-4      	; 0x13e <main+0x8>
	 
	_delay_ms(10); // 10 Millisecond Delay for Transition

	DDRD |= LEDOK | LEDS5; //Define LED Pins as Outputs
 142:	8a b1       	in	r24, 0x0a	; 10
 144:	80 66       	ori	r24, 0x60	; 96
 146:	8a b9       	out	0x0a, r24	; 10
	PORTD |= LEDOK;
 148:	5e 9a       	sbi	0x0b, 6	; 11
 14a:	20 e9       	ldi	r18, 0x90	; 144
 14c:	31 e0       	ldi	r19, 0x01	; 1

	/* Main Loop */
	while(1) 
	{
		wdt_reset();
 14e:	a8 95       	wdr
 150:	88 ee       	ldi	r24, 0xE8	; 232
 152:	93 e0       	ldi	r25, 0x03	; 3
 154:	f9 01       	movw	r30, r18
 156:	31 97       	sbiw	r30, 0x01	; 1
 158:	f1 f7       	brne	.-4      	; 0x156 <main+0x20>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 15a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 15c:	d9 f7       	brne	.-10     	; 0x154 <main+0x1e>
 15e:	f7 cf       	rjmp	.-18     	; 0x14e <main+0x18>

00000160 <uart_init>:
#include "uart.h"

void uart_init(void)
{	
	/* Set Baud Rate */
	UBRR0H = (char) (MYUBRR >> 8);
 160:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (char) (MYUBRR);
 164:	83 e0       	ldi	r24, 0x03	; 3
 166:	80 93 c4 00 	sts	0x00C4, r24
	
	/* Set Frame Format: 8 Data, 1 Stop, No Parity */
	UCSR0C = (0 << UPM00) | (0 << USBS0) | (3 << UCSZ00); 		
 16a:	86 e0       	ldi	r24, 0x06	; 6
 16c:	80 93 c2 00 	sts	0x00C2, r24

	/* Enable TX and RX + RX Interrupt */
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
 170:	88 e9       	ldi	r24, 0x98	; 152
 172:	80 93 c1 00 	sts	0x00C1, r24
}
 176:	08 95       	ret

00000178 <uart_read>:

/* Reads Incoming UART Data */
char uart_read(void)
{
	/* Waits for Transmission Complete */
	while ( !(UCSR0A & (1 << RXC0)));
 178:	80 91 c0 00 	lds	r24, 0x00C0
 17c:	87 ff       	sbrs	r24, 7
 17e:	fc cf       	rjmp	.-8      	; 0x178 <uart_read>
	
	/* Reads Data and Returns */
	return UDR0;
 180:	80 91 c6 00 	lds	r24, 0x00C6
} 
 184:	08 95       	ret

00000186 <uart_write>:

/* Function for Transmiting Through UART */
void uart_write(char data)
{
 186:	98 2f       	mov	r25, r24
	/* Waits for completion of previous transmission */
	while( !( UCSR0A & (1 << UDRE0)));
 188:	80 91 c0 00 	lds	r24, 0x00C0
 18c:	85 ff       	sbrs	r24, 5
 18e:	fc cf       	rjmp	.-8      	; 0x188 <uart_write+0x2>

	/* Puts Data on buffer */
	UDR0 = data;
 190:	90 93 c6 00 	sts	0x00C6, r25
}
 194:	08 95       	ret

00000196 <uart_write2>:

/* Function for Writing Ints Into UART */
void uart_write2(int data)
{
 196:	9c 01       	movw	r18, r24
	/* Waits for completion of previous transmission */
	while( !( UCSR0A & (1 << UDRE0)));
 198:	80 91 c0 00 	lds	r24, 0x00C0
 19c:	85 ff       	sbrs	r24, 5
 19e:	fc cf       	rjmp	.-8      	; 0x198 <uart_write2+0x2>

	/* Puts Data on buffer */
	UDR0 = (char) data;
 1a0:	20 93 c6 00 	sts	0x00C6, r18

	/* Waits for completion of previous transmission */
	while( !( UCSR0A & (1 << UDRE0)));
 1a4:	80 91 c0 00 	lds	r24, 0x00C0
 1a8:	85 ff       	sbrs	r24, 5
 1aa:	fc cf       	rjmp	.-8      	; 0x1a4 <uart_write2+0xe>

	/* Puts Data on buffer */
	UDR0 = (char) (data >> 8);
 1ac:	83 2f       	mov	r24, r19
 1ae:	99 27       	eor	r25, r25
 1b0:	87 fd       	sbrc	r24, 7
 1b2:	9a 95       	dec	r25
 1b4:	80 93 c6 00 	sts	0x00C6, r24
}
 1b8:	08 95       	ret

000001ba <__vector_18>:

/* Interrupt For Handling UART Reception (Receive Complete) */	 
ISR (USART_RX_vect)
{
 1ba:	1f 92       	push	r1
 1bc:	0f 92       	push	r0
 1be:	0f b6       	in	r0, 0x3f	; 63
 1c0:	0f 92       	push	r0
 1c2:	11 24       	eor	r1, r1
 1c4:	8f 93       	push	r24
	/*Temporarily Disable Interrupts */
	cli(); 
 1c6:	f8 94       	cli

	/* Declare Variables */
	char Pic_Data = 0;

	/* Read UART Byte */
	Pic_Data = UDR0;		
 1c8:	80 91 c6 00 	lds	r24, 0x00C6

	/* Only Store Data if First Packet is 255 */
	if (Pic_Data == 0xFF)
 1cc:	8f 3f       	cpi	r24, 0xFF	; 255
 1ce:	31 f4       	brne	.+12     	; 0x1dc <__vector_18+0x22>

/* Reads Incoming UART Data */
char uart_read(void)
{
	/* Waits for Transmission Complete */
	while ( !(UCSR0A & (1 << RXC0)));
 1d0:	80 91 c0 00 	lds	r24, 0x00C0
 1d4:	87 ff       	sbrs	r24, 7
 1d6:	fc cf       	rjmp	.-8      	; 0x1d0 <__vector_18+0x16>
	
	/* Reads Data and Returns */
	return UDR0;
 1d8:	80 91 c6 00 	lds	r24, 0x00C6
			break;
		}
	}

	/* Reenable Interrupts */
	sei();
 1dc:	78 94       	sei
}	
 1de:	8f 91       	pop	r24
 1e0:	0f 90       	pop	r0
 1e2:	0f be       	out	0x3f, r0	; 63
 1e4:	0f 90       	pop	r0
 1e6:	1f 90       	pop	r1
 1e8:	18 95       	reti

000001ea <wdt_init>:
#include <avr/interrupt.h>

/* Initializes WDT */
void wdt_init(uint8_t scaller)
{
	WDTCSR |= (1 << WDE) | (1 << WDCE); // First Step in Setting Timer
 1ea:	e0 e6       	ldi	r30, 0x60	; 96
 1ec:	f0 e0       	ldi	r31, 0x00	; 0
 1ee:	90 81       	ld	r25, Z
 1f0:	98 61       	ori	r25, 0x18	; 24
 1f2:	90 83       	st	Z, r25
	WDTCSR = (1 << WDE) | (scaller << WDP0); //Enables WDT and Sets Prescaller
 1f4:	88 60       	ori	r24, 0x08	; 8
 1f6:	80 83       	st	Z, r24
}
 1f8:	08 95       	ret

000001fa <wdt_reset>:

void wdt_reset(void)
{
	__asm__ __volatile__ ("wdr");
 1fa:	a8 95       	wdr
}
 1fc:	08 95       	ret

000001fe <adc_init>:
uint8_t stop = 0;

/* Function to Initialize ADC */
void adc_init(void)
{
	ADCSRA = (1 << ADEN) | (7 << ADPS0);
 1fe:	87 e8       	ldi	r24, 0x87	; 135
 200:	80 93 7a 00 	sts	0x007A, r24
}
 204:	08 95       	ret

00000206 <adc_read>:

/* Function for Reading ADC */
int adc_read(char channel)
{
	int data; //Variable to Store Read Data
	ADMUX = (0x0F & (channel << MUX0)); //Select ADC Pin to Read with Safety Mask
 206:	8f 70       	andi	r24, 0x0F	; 15
 208:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = (1 << ADSC); //Starts Conversion and Enables Interrupt
 20c:	80 e4       	ldi	r24, 0x40	; 64
 20e:	80 93 7a 00 	sts	0x007A, r24
	while( ! (ADCSRA & (1 << ADSC))); //Holds Program Until Conversion is Done
 212:	80 91 7a 00 	lds	r24, 0x007A
 216:	86 ff       	sbrs	r24, 6
 218:	fc cf       	rjmp	.-8      	; 0x212 <adc_read+0xc>
	stop = 0;
 21a:	10 92 00 01 	sts	0x0100, r1
	/* Read Data */
	data = (ADCL);
 21e:	20 91 78 00 	lds	r18, 0x0078
 222:	30 e0       	ldi	r19, 0x00	; 0
	data |= (ADCH << 8);
 224:	40 91 79 00 	lds	r20, 0x0079
 228:	94 2f       	mov	r25, r20
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	28 2b       	or	r18, r24
 22e:	39 2b       	or	r19, r25

	return data; //Return Data
}
 230:	c9 01       	movw	r24, r18
 232:	08 95       	ret

00000234 <spi_init>:

/* Function for Initializing SPI */
void spi_init(void)
{
	/* Define Direction for SPI Ports: MOSI, SCK, SS, RESET OUTPUTS; MISO INPUT */
	DDRB |= (1 << MOSI) | (1 << SCK) | (1 << SS);
 234:	84 b1       	in	r24, 0x04	; 4
 236:	8c 62       	ori	r24, 0x2C	; 44
 238:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~(1 << MISO);
 23a:	24 98       	cbi	0x04, 4	; 4
	DDRD |= (1 << RESET);
 23c:	57 9a       	sbi	0x0a, 7	; 10

	/* Enable Interrupt, SPI Enable, MSB First, Clock Idle Low, Sample First, FOSC / 4 */ 
	SPCR = (1 << SPE) | (0 << DORD) | (1 << MSTR) | (0 << SPR0);
 23e:	80 e5       	ldi	r24, 0x50	; 80
 240:	8c bd       	out	0x2c, r24	; 44
	
	/* Enable External Interrupt 1 for DRDY from MAG */
	EICRA |= (2 << ISC10); //Set to Falling Edge
 242:	e9 e6       	ldi	r30, 0x69	; 105
 244:	f0 e0       	ldi	r31, 0x00	; 0
 246:	80 81       	ld	r24, Z
 248:	88 60       	ori	r24, 0x08	; 8
 24a:	80 83       	st	Z, r24
	EIMSK |= (1 << INT1); //Turn on Interrupt 
 24c:	e9 9a       	sbi	0x1d, 1	; 29
}
 24e:	08 95       	ret

00000250 <spi_write>:

/* Function for Sending Serial Data */
void spi_write(char data)
{
	/* Reset Magnetometer and Bring SS LOW */
	PORTD |= (1 << RESET);
 250:	5f 9a       	sbi	0x0b, 7	; 11
	PORTB &= ~(1 << SS);
 252:	2a 98       	cbi	0x05, 2	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 254:	9a e1       	ldi	r25, 0x1A	; 26
 256:	29 2f       	mov	r18, r25
 258:	2a 95       	dec	r18
 25a:	f1 f7       	brne	.-4      	; 0x258 <spi_write+0x8>
	_delay_us(5);
	PORTD &= ~(1 << RESET);
 25c:	5f 98       	cbi	0x0b, 7	; 11
 25e:	9a 95       	dec	r25
 260:	f1 f7       	brne	.-4      	; 0x25e <spi_write+0xe>
	_delay_us(5);
	
	/* Write Data on Register */
	SPDR = data;
 262:	8e bd       	out	0x2e, r24	; 46
	while( !(SPSR & (1 << SPIF)));
 264:	0d b4       	in	r0, 0x2d	; 45
 266:	07 fe       	sbrs	r0, 7
 268:	fd cf       	rjmp	.-6      	; 0x264 <spi_write+0x14>
	// REQUIRES CHECKING AND COMPLETION!!!!!!!!!!!!!
}
 26a:	08 95       	ret

0000026c <spi_read>:

uint16_t spi_read(void)
{
	uint16_t data = 0;
	/* Waits for Data to be Received */
	while( !(SPSR & (1 << SPIF)));
 26c:	0d b4       	in	r0, 0x2d	; 45
 26e:	07 fe       	sbrs	r0, 7
 270:	fd cf       	rjmp	.-6      	; 0x26c <spi_read>

	/* Reads Received Data */
	data = (SPDR << 8);
 272:	3e b5       	in	r19, 0x2e	; 46

	/* Wait for Second Byte and Read */
	while( !(SPSR & (1 << SPIF)));
 274:	0d b4       	in	r0, 0x2d	; 45
 276:	07 fe       	sbrs	r0, 7
 278:	fd cf       	rjmp	.-6      	; 0x274 <spi_read+0x8>
	data |= (SPDR);
 27a:	2e b5       	in	r18, 0x2e	; 46
	uint16_t data = 0;
	/* Waits for Data to be Received */
	while( !(SPSR & (1 << SPIF)));

	/* Reads Received Data */
	data = (SPDR << 8);
 27c:	93 2f       	mov	r25, r19
 27e:	80 e0       	ldi	r24, 0x00	; 0
 280:	30 e0       	ldi	r19, 0x00	; 0
 282:	28 2b       	or	r18, r24
 284:	39 2b       	or	r19, r25
	while( !(SPSR & (1 << SPIF)));
	data |= (SPDR);

	/* Return Value */
	return data;
}
 286:	c9 01       	movw	r24, r18
 288:	08 95       	ret

0000028a <__vector_2>:

ISR (INT1_vect)
{
 28a:	1f 92       	push	r1
 28c:	0f 92       	push	r0
 28e:	0f b6       	in	r0, 0x3f	; 63
 290:	0f 92       	push	r0
 292:	11 24       	eor	r1, r1
 294:	2f 93       	push	r18
 296:	3f 93       	push	r19
 298:	4f 93       	push	r20
 29a:	5f 93       	push	r21
 29c:	6f 93       	push	r22
 29e:	7f 93       	push	r23
 2a0:	8f 93       	push	r24
 2a2:	9f 93       	push	r25
 2a4:	af 93       	push	r26
 2a6:	bf 93       	push	r27
 2a8:	ef 93       	push	r30
 2aa:	ff 93       	push	r31
	/* Redeclare External Variable for Usage */
	uint16_t Mag_Data = 0;
	Mag_Data = spi_read();
 2ac:	0e 94 36 01 	call	0x26c	; 0x26c <spi_read>
}
 2b0:	ff 91       	pop	r31
 2b2:	ef 91       	pop	r30
 2b4:	bf 91       	pop	r27
 2b6:	af 91       	pop	r26
 2b8:	9f 91       	pop	r25
 2ba:	8f 91       	pop	r24
 2bc:	7f 91       	pop	r23
 2be:	6f 91       	pop	r22
 2c0:	5f 91       	pop	r21
 2c2:	4f 91       	pop	r20
 2c4:	3f 91       	pop	r19
 2c6:	2f 91       	pop	r18
 2c8:	0f 90       	pop	r0
 2ca:	0f be       	out	0x3f, r0	; 63
 2cc:	0f 90       	pop	r0
 2ce:	1f 90       	pop	r1
 2d0:	18 95       	reti

000002d2 <i2c_reg_write>:

#include "i2c.h"

/* Function for Writing into Sensor Registers */
void i2c_reg_write(char device, char reg, char data)
{
 2d2:	0f 93       	push	r16
 2d4:	1f 93       	push	r17
 2d6:	16 2f       	mov	r17, r22
 2d8:	04 2f       	mov	r16, r20
	/* Starts i2C interface */
	i2c_start(device + I2C_WRITE);
 2da:	0e 94 4e 02 	call	0x49c	; 0x49c <i2c_start>

	/* Send Register Adress */
	i2c_write(reg);
 2de:	81 2f       	mov	r24, r17
 2e0:	0e 94 a7 02 	call	0x54e	; 0x54e <i2c_write>

	/* Sends Desired Register Value */
	i2c_write(data);
 2e4:	80 2f       	mov	r24, r16
 2e6:	0e 94 a7 02 	call	0x54e	; 0x54e <i2c_write>
}
 2ea:	1f 91       	pop	r17
 2ec:	0f 91       	pop	r16
 2ee:	08 95       	ret

000002f0 <accel_init>:

/* Initializes Accelerometer */
void accel_init(void)
{
	/* Put Device Into StandBy */
	i2c_reg_write(ACCELADRESS, POWER_CTL, 0x00);
 2f0:	86 ea       	ldi	r24, 0xA6	; 166
 2f2:	6d e2       	ldi	r22, 0x2D	; 45
 2f4:	40 e0       	ldi	r20, 0x00	; 0
 2f6:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Put Device into auto sleep */
	i2c_reg_write(ACCELADRESS, POWER_CTL, (1 << AUTO_SLEEP));
 2fa:	86 ea       	ldi	r24, 0xA6	; 166
 2fc:	6d e2       	ldi	r22, 0x2D	; 45
 2fe:	40 e1       	ldi	r20, 0x10	; 16
 300:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Put Device Into Measurement Mode */
	i2c_reg_write(ACCELADRESS, POWER_CTL, (1 << MEASURE));
 304:	86 ea       	ldi	r24, 0xA6	; 166
 306:	6d e2       	ldi	r22, 0x2D	; 45
 308:	48 e0       	ldi	r20, 0x08	; 8
 30a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Enable Interrupt */
	i2c_reg_write(ACCELADRESS, INT_ENABLE, (1 << DATA_READY));
 30e:	86 ea       	ldi	r24, 0xA6	; 166
 310:	6e e2       	ldi	r22, 0x2E	; 46
 312:	40 e8       	ldi	r20, 0x80	; 128
 314:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Select Input Source */
	i2c_reg_write(ACCELADRESS, INT_MAP, ~(1 << DATA_READY));
 318:	86 ea       	ldi	r24, 0xA6	; 166
 31a:	6f e2       	ldi	r22, 0x2F	; 47
 31c:	4f e7       	ldi	r20, 0x7F	; 127
 31e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Define Data Format and Range */
	i2c_reg_write(ACCELADRESS, DATA_FORMAT, ((0 << JUSTIFY) | (1 << RANGE)));
 322:	86 ea       	ldi	r24, 0xA6	; 166
 324:	61 e3       	ldi	r22, 0x31	; 49
 326:	41 e0       	ldi	r20, 0x01	; 1
 328:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Define Sample Rate */
	i2c_reg_write(ACCELADRESS, BW_RATE, (11 << RATE));
 32c:	86 ea       	ldi	r24, 0xA6	; 166
 32e:	6c e2       	ldi	r22, 0x2C	; 44
 330:	4b e0       	ldi	r20, 0x0B	; 11
 332:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
	
	/* Bypass Filter */
	i2c_reg_write(ACCELADRESS, FIFO_CTL, 0x00);
 336:	86 ea       	ldi	r24, 0xA6	; 166
 338:	68 e3       	ldi	r22, 0x38	; 56
 33a:	40 e0       	ldi	r20, 0x00	; 0
 33c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
}			
 340:	08 95       	ret

00000342 <gyro_init>:

/* Configures Gyro */ 
void gyro_init(void)
{	
	/* Reset IMU */
	i2c_reg_write(GYROADRESS, PWR_MGM, (1 << H_RESET)); 
 342:	80 ed       	ldi	r24, 0xD0	; 208
 344:	6e e3       	ldi	r22, 0x3E	; 62
 346:	40 e8       	ldi	r20, 0x80	; 128
 348:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 34c:	80 ed       	ldi	r24, 0xD0	; 208
 34e:	97 e0       	ldi	r25, 0x07	; 7
 350:	01 97       	sbiw	r24, 0x01	; 1
 352:	f1 f7       	brne	.-4      	; 0x350 <gyro_init+0xe>
	
	/* Delay After Reset */
	_delay_us(500); 

	/* Changes Clock Source (Internal Clock) */
	i2c_reg_write(GYROADRESS, PWR_MGM, (0 << CLK_SEL));
 354:	80 ed       	ldi	r24, 0xD0	; 208
 356:	6e e3       	ldi	r22, 0x3E	; 62
 358:	40 e0       	ldi	r20, 0x00	; 0
 35a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>

	/* Sample Rate to 200 hz (0x07 = 200 hz) */
	i2c_reg_write(GYROADRESS, SMPLRT_DIV, 0x04);
 35e:	80 ed       	ldi	r24, 0xD0	; 208
 360:	65 e1       	ldi	r22, 0x15	; 21
 362:	44 e0       	ldi	r20, 0x04	; 4
 364:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>

	/* Full Range + 5 hz LPF @ 1 KHZ */
	i2c_reg_write(GYROADRESS, DLPF_FS, ((3 << FS_SEL) | (6 << DLPF_CFG)));
 368:	80 ed       	ldi	r24, 0xD0	; 208
 36a:	66 e1       	ldi	r22, 0x16	; 22
 36c:	4e e1       	ldi	r20, 0x1E	; 30
 36e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>

	/* Program Interrupt and Relieve Method For Interrupt */
	i2c_reg_write(GYROADRESS, INT_CFG, ((0 << LATCH_INT_EN) | (0 << INT_ANYRD_2CLEAR) | (1 << RAW_RDY_EN)));
 372:	80 ed       	ldi	r24, 0xD0	; 208
 374:	67 e1       	ldi	r22, 0x17	; 23
 376:	41 e0       	ldi	r20, 0x01	; 1
 378:	0e 94 69 01 	call	0x2d2	; 0x2d2 <i2c_reg_write>
}
 37c:	08 95       	ret

0000037e <accel_read>:
	i2c_reg_write(ACCELADRESS, FIFO_CTL, 0x00);
}			

/* Reads Data From Accelerometer */
void accel_read(int *ptr)
{
 37e:	ef 92       	push	r14
 380:	ff 92       	push	r15
 382:	0f 93       	push	r16
 384:	1f 93       	push	r17
 386:	7c 01       	movw	r14, r24
	/* Start Comunication and Send Register Adress */
	i2c_start(ACCELADRESS+I2C_WRITE);
 388:	86 ea       	ldi	r24, 0xA6	; 166
 38a:	0e 94 4e 02 	call	0x49c	; 0x49c <i2c_start>
	i2c_write(DATAX0);
 38e:	82 e3       	ldi	r24, 0x32	; 50
 390:	0e 94 a7 02 	call	0x54e	; 0x54e <i2c_write>

	/* Send Repeated Start and Read Registers*/
	i2c_rep_start(ACCELADRESS+I2C_READ);
 394:	87 ea       	ldi	r24, 0xA7	; 167
 396:	0e 94 9c 02 	call	0x538	; 0x538 <i2c_rep_start>

	/* Read All Axis */
	ptr[0] = i2c_readAck() | (i2c_readAck() << 8); // X Axis
 39a:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 39e:	08 2f       	mov	r16, r24
 3a0:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 3a4:	38 2f       	mov	r19, r24
 3a6:	20 e0       	ldi	r18, 0x00	; 0
 3a8:	10 e0       	ldi	r17, 0x00	; 0
 3aa:	20 2b       	or	r18, r16
 3ac:	31 2b       	or	r19, r17
 3ae:	f7 01       	movw	r30, r14
 3b0:	31 83       	std	Z+1, r19	; 0x01
 3b2:	20 83       	st	Z, r18
	ptr[1] = i2c_readAck() | (i2c_readAck() << 8); // Y Axis
 3b4:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 3b8:	08 2f       	mov	r16, r24
 3ba:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 3be:	38 2f       	mov	r19, r24
 3c0:	20 e0       	ldi	r18, 0x00	; 0
 3c2:	10 e0       	ldi	r17, 0x00	; 0
 3c4:	20 2b       	or	r18, r16
 3c6:	31 2b       	or	r19, r17
 3c8:	f7 01       	movw	r30, r14
 3ca:	33 83       	std	Z+3, r19	; 0x03
 3cc:	22 83       	std	Z+2, r18	; 0x02
	ptr[2] = i2c_readAck() | (i2c_readNak() << 8); // Z Axis
 3ce:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 3d2:	08 2f       	mov	r16, r24
 3d4:	0e 94 c3 02 	call	0x586	; 0x586 <i2c_readNak>
 3d8:	38 2f       	mov	r19, r24
 3da:	20 e0       	ldi	r18, 0x00	; 0
 3dc:	10 e0       	ldi	r17, 0x00	; 0
 3de:	20 2b       	or	r18, r16
 3e0:	31 2b       	or	r19, r17
 3e2:	f7 01       	movw	r30, r14
 3e4:	35 83       	std	Z+5, r19	; 0x05
 3e6:	24 83       	std	Z+4, r18	; 0x04

	/* Stop i2c */
	i2c_stop();
 3e8:	0e 94 9f 02 	call	0x53e	; 0x53e <i2c_stop>
}
 3ec:	1f 91       	pop	r17
 3ee:	0f 91       	pop	r16
 3f0:	ff 90       	pop	r15
 3f2:	ef 90       	pop	r14
 3f4:	08 95       	ret

000003f6 <gyro_read>:
	i2c_reg_write(GYROADRESS, INT_CFG, ((0 << LATCH_INT_EN) | (0 << INT_ANYRD_2CLEAR) | (1 << RAW_RDY_EN)));
}

/* Reads Gyro Data and Store On External Array */
void gyro_read(int *ptr)
{
 3f6:	ef 92       	push	r14
 3f8:	ff 92       	push	r15
 3fa:	1f 93       	push	r17
 3fc:	7c 01       	movw	r14, r24
	/* Start Comunication and Send Register Adress */
	i2c_start(GYROADRESS+I2C_WRITE);
 3fe:	80 ed       	ldi	r24, 0xD0	; 208
 400:	0e 94 4e 02 	call	0x49c	; 0x49c <i2c_start>
	i2c_write(GYROREGADRESS);
 404:	8b e1       	ldi	r24, 0x1B	; 27
 406:	0e 94 a7 02 	call	0x54e	; 0x54e <i2c_write>

	/* Send Repeated Start and Read Registers*/
	i2c_rep_start(GYROADRESS+I2C_READ);
 40a:	81 ed       	ldi	r24, 0xD1	; 209
 40c:	0e 94 9c 02 	call	0x538	; 0x538 <i2c_rep_start>

	/* Read All Axis and Add Offsets */
	ptr[3] = (i2c_readAck() << 8) |  i2c_readAck(); //Temperature
 410:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 414:	18 2f       	mov	r17, r24
 416:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 41a:	31 2f       	mov	r19, r17
 41c:	20 e0       	ldi	r18, 0x00	; 0
 41e:	90 e0       	ldi	r25, 0x00	; 0
 420:	28 2b       	or	r18, r24
 422:	39 2b       	or	r19, r25
 424:	f7 01       	movw	r30, r14
 426:	37 83       	std	Z+7, r19	; 0x07
 428:	26 83       	std	Z+6, r18	; 0x06
	ptr[0] = ((i2c_readAck() << 8) |  i2c_readAck()) + X_OFFSET; // X Axis
 42a:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 42e:	18 2f       	mov	r17, r24
 430:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 434:	31 2f       	mov	r19, r17
 436:	20 e0       	ldi	r18, 0x00	; 0
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	28 2b       	or	r18, r24
 43c:	39 2b       	or	r19, r25
 43e:	29 5e       	subi	r18, 0xE9	; 233
 440:	3f 4f       	sbci	r19, 0xFF	; 255
 442:	f7 01       	movw	r30, r14
 444:	31 83       	std	Z+1, r19	; 0x01
 446:	20 83       	st	Z, r18
	ptr[1] = ((i2c_readAck() << 8) |  i2c_readAck()) + Y_OFFSET; // Y Axis
 448:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 44c:	18 2f       	mov	r17, r24
 44e:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 452:	31 2f       	mov	r19, r17
 454:	20 e0       	ldi	r18, 0x00	; 0
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	28 2b       	or	r18, r24
 45a:	39 2b       	or	r19, r25
 45c:	29 5f       	subi	r18, 0xF9	; 249
 45e:	3f 4f       	sbci	r19, 0xFF	; 255
 460:	f7 01       	movw	r30, r14
 462:	33 83       	std	Z+3, r19	; 0x03
 464:	22 83       	std	Z+2, r18	; 0x02
	ptr[2] = ((i2c_readAck() << 8) |  i2c_readNak()) + Z_OFFSET; // Z Axis
 466:	0e 94 b9 02 	call	0x572	; 0x572 <i2c_readAck>
 46a:	18 2f       	mov	r17, r24
 46c:	0e 94 c3 02 	call	0x586	; 0x586 <i2c_readNak>
 470:	31 2f       	mov	r19, r17
 472:	20 e0       	ldi	r18, 0x00	; 0
 474:	90 e0       	ldi	r25, 0x00	; 0
 476:	28 2b       	or	r18, r24
 478:	39 2b       	or	r19, r25
 47a:	26 5f       	subi	r18, 0xF6	; 246
 47c:	3f 4f       	sbci	r19, 0xFF	; 255
 47e:	f7 01       	movw	r30, r14
 480:	35 83       	std	Z+5, r19	; 0x05
 482:	24 83       	std	Z+4, r18	; 0x04

	/* Stop i2c */
	i2c_stop();
 484:	0e 94 9f 02 	call	0x53e	; 0x53e <i2c_stop>
}	
 488:	1f 91       	pop	r17
 48a:	ff 90       	pop	r15
 48c:	ef 90       	pop	r14
 48e:	08 95       	ret

00000490 <i2c_init>:
*************************************************************************/
void i2c_init(void)
{
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  
  TWSR = 0;                         /* no prescaler */
 490:	10 92 b9 00 	sts	0x00B9, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
 494:	8c e0       	ldi	r24, 0x0C	; 12
 496:	80 93 b8 00 	sts	0x00B8, r24

}/* i2c_init */
 49a:	08 95       	ret

0000049c <i2c_start>:
/*************************************************************************	
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
 49c:	98 2f       	mov	r25, r24
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 49e:	84 ea       	ldi	r24, 0xA4	; 164
 4a0:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 4a4:	80 91 bc 00 	lds	r24, 0x00BC
 4a8:	87 ff       	sbrs	r24, 7
 4aa:	fc cf       	rjmp	.-8      	; 0x4a4 <i2c_start+0x8>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 4ac:	80 91 b9 00 	lds	r24, 0x00B9
 4b0:	88 7f       	andi	r24, 0xF8	; 248
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 4b2:	88 30       	cpi	r24, 0x08	; 8
 4b4:	21 f0       	breq	.+8      	; 0x4be <i2c_start+0x22>
 4b6:	80 31       	cpi	r24, 0x10	; 16
 4b8:	11 f0       	breq	.+4      	; 0x4be <i2c_start+0x22>
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	08 95       	ret

	// send device address
	TWDR = address;
 4be:	90 93 bb 00 	sts	0x00BB, r25
	TWCR = (1<<TWINT) | (1<<TWEN);
 4c2:	84 e8       	ldi	r24, 0x84	; 132
 4c4:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 4c8:	80 91 bc 00 	lds	r24, 0x00BC
 4cc:	87 ff       	sbrs	r24, 7
 4ce:	fc cf       	rjmp	.-8      	; 0x4c8 <i2c_start+0x2c>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 4d0:	90 91 b9 00 	lds	r25, 0x00B9
 4d4:	98 7f       	andi	r25, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 4d6:	98 31       	cpi	r25, 0x18	; 24
 4d8:	11 f4       	brne	.+4      	; 0x4de <i2c_start+0x42>
 4da:	80 e0       	ldi	r24, 0x00	; 0
 4dc:	08 95       	ret
 4de:	80 e0       	ldi	r24, 0x00	; 0
 4e0:	90 34       	cpi	r25, 0x40	; 64
 4e2:	09 f0       	breq	.+2      	; 0x4e6 <i2c_start+0x4a>
 4e4:	81 e0       	ldi	r24, 0x01	; 1

	return 0;

}/* i2c_start */
 4e6:	08 95       	ret

000004e8 <i2c_start_wait>:
 If device is busy, use ack polling to wait until device is ready
 
 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
 4e8:	98 2f       	mov	r25, r24


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 4ea:	44 ea       	ldi	r20, 0xA4	; 164
    	twst = TW_STATUS & 0xF8;
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
    
    	// send device address
    	TWDR = address;
    	TWCR = (1<<TWINT) | (1<<TWEN);
 4ec:	34 e8       	ldi	r19, 0x84	; 132
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 4ee:	24 e9       	ldi	r18, 0x94	; 148


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 4f0:	40 93 bc 00 	sts	0x00BC, r20
    
    	// wait until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 4f4:	80 91 bc 00 	lds	r24, 0x00BC
 4f8:	87 ff       	sbrs	r24, 7
 4fa:	fc cf       	rjmp	.-8      	; 0x4f4 <i2c_start_wait+0xc>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 4fc:	80 91 b9 00 	lds	r24, 0x00B9
 500:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 502:	88 30       	cpi	r24, 0x08	; 8
 504:	11 f0       	breq	.+4      	; 0x50a <i2c_start_wait+0x22>
 506:	80 31       	cpi	r24, 0x10	; 16
 508:	99 f7       	brne	.-26     	; 0x4f0 <i2c_start_wait+0x8>
    
    	// send device address
    	TWDR = address;
 50a:	90 93 bb 00 	sts	0x00BB, r25
    	TWCR = (1<<TWINT) | (1<<TWEN);
 50e:	30 93 bc 00 	sts	0x00BC, r19
    
    	// wail until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 512:	80 91 bc 00 	lds	r24, 0x00BC
 516:	87 ff       	sbrs	r24, 7
 518:	fc cf       	rjmp	.-8      	; 0x512 <i2c_start_wait+0x2a>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 51a:	80 91 b9 00 	lds	r24, 0x00B9
 51e:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 520:	80 32       	cpi	r24, 0x20	; 32
 522:	11 f0       	breq	.+4      	; 0x528 <i2c_start_wait+0x40>
 524:	88 35       	cpi	r24, 0x58	; 88
 526:	39 f4       	brne	.+14     	; 0x536 <i2c_start_wait+0x4e>
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 528:	20 93 bc 00 	sts	0x00BC, r18
	        
	        // wait until stop condition is executed and bus released
	        while(TWCR & (1<<TWSTO));
 52c:	80 91 bc 00 	lds	r24, 0x00BC
 530:	84 fd       	sbrc	r24, 4
 532:	fc cf       	rjmp	.-8      	; 0x52c <i2c_start_wait+0x44>
 534:	dd cf       	rjmp	.-70     	; 0x4f0 <i2c_start_wait+0x8>
 536:	08 95       	ret

00000538 <i2c_rep_start>:
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );
 538:	0e 94 4e 02 	call	0x49c	; 0x49c <i2c_start>

}/* i2c_rep_start */
 53c:	08 95       	ret

0000053e <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 53e:	84 e9       	ldi	r24, 0x94	; 148
 540:	80 93 bc 00 	sts	0x00BC, r24
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 544:	80 91 bc 00 	lds	r24, 0x00BC
 548:	84 fd       	sbrc	r24, 4
 54a:	fc cf       	rjmp	.-8      	; 0x544 <i2c_stop+0x6>

}/* i2c_stop */
 54c:	08 95       	ret

0000054e <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
 54e:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 552:	84 e8       	ldi	r24, 0x84	; 132
 554:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 558:	80 91 bc 00 	lds	r24, 0x00BC
 55c:	87 ff       	sbrs	r24, 7
 55e:	fc cf       	rjmp	.-8      	; 0x558 <i2c_write+0xa>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
 560:	80 91 b9 00 	lds	r24, 0x00B9
 564:	90 e0       	ldi	r25, 0x00	; 0
 566:	88 7f       	andi	r24, 0xF8	; 248
 568:	88 32       	cpi	r24, 0x28	; 40
 56a:	09 f0       	breq	.+2      	; 0x56e <i2c_write+0x20>
 56c:	91 e0       	ldi	r25, 0x01	; 1
	if( twst != TW_MT_DATA_ACK) return 1;
	return 0;

}/* i2c_write */
 56e:	89 2f       	mov	r24, r25
 570:	08 95       	ret

00000572 <i2c_readAck>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 572:	84 ec       	ldi	r24, 0xC4	; 196
 574:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));    
 578:	80 91 bc 00 	lds	r24, 0x00BC
 57c:	87 ff       	sbrs	r24, 7
 57e:	fc cf       	rjmp	.-8      	; 0x578 <i2c_readAck+0x6>

    return TWDR;
 580:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readAck */
 584:	08 95       	ret

00000586 <i2c_readNak>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
 586:	84 e8       	ldi	r24, 0x84	; 132
 588:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));
 58c:	80 91 bc 00 	lds	r24, 0x00BC
 590:	87 ff       	sbrs	r24, 7
 592:	fc cf       	rjmp	.-8      	; 0x58c <i2c_readNak+0x6>
	
    return TWDR;
 594:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readNak */
 598:	08 95       	ret

0000059a <interrupt_init>:

/* Activates the PCINT Interrupt Used for Gyro */
void gyro_interrupt_init()
{
	/* Activates PCINT Interrupts from Pin 0 - 7 that are enabled in PCMSK */
	PCICR |= (1 << PCIE0);
 59a:	a8 e6       	ldi	r26, 0x68	; 104
 59c:	b0 e0       	ldi	r27, 0x00	; 0
 59e:	8c 91       	ld	r24, X
 5a0:	81 60       	ori	r24, 0x01	; 1
 5a2:	8c 93       	st	X, r24

	/* Activates Specific Interrupt */
	PCMSK0 |= (1 << PCINT0);
 5a4:	eb e6       	ldi	r30, 0x6B	; 107
 5a6:	f0 e0       	ldi	r31, 0x00	; 0
 5a8:	80 81       	ld	r24, Z
 5aa:	81 60       	ori	r24, 0x01	; 1
 5ac:	80 83       	st	Z, r24

/* Activates the PCINT Interrupt Used for Accel */
void accel_interrupt_init()
{
	/* Activates PCINT Interrupts from Pin 0 - 7 that are enabled in PCMSK */
	PCICR |= (1 << PCIE0);
 5ae:	8c 91       	ld	r24, X
 5b0:	81 60       	ori	r24, 0x01	; 1
 5b2:	8c 93       	st	X, r24

	/* Activates Specific Interrupt */
	PCMSK0 |= (1 << PCINT1);
 5b4:	80 81       	ld	r24, Z
 5b6:	82 60       	ori	r24, 0x02	; 2
 5b8:	80 83       	st	Z, r24
/* Activates External and Pin Interrupts */
void interrupt_init(void)
{
	gyro_interrupt_init();
	accel_interrupt_init();
}
 5ba:	08 95       	ret

000005bc <gyro_interrupt_init>:

/* Activates the PCINT Interrupt Used for Gyro */
void gyro_interrupt_init()
{
	/* Activates PCINT Interrupts from Pin 0 - 7 that are enabled in PCMSK */
	PCICR |= (1 << PCIE0);
 5bc:	e8 e6       	ldi	r30, 0x68	; 104
 5be:	f0 e0       	ldi	r31, 0x00	; 0
 5c0:	80 81       	ld	r24, Z
 5c2:	81 60       	ori	r24, 0x01	; 1
 5c4:	80 83       	st	Z, r24

	/* Activates Specific Interrupt */
	PCMSK0 |= (1 << PCINT0);
 5c6:	eb e6       	ldi	r30, 0x6B	; 107
 5c8:	f0 e0       	ldi	r31, 0x00	; 0
 5ca:	80 81       	ld	r24, Z
 5cc:	81 60       	ori	r24, 0x01	; 1
 5ce:	80 83       	st	Z, r24
}
 5d0:	08 95       	ret

000005d2 <accel_interrupt_init>:

/* Activates the PCINT Interrupt Used for Accel */
void accel_interrupt_init()
{
	/* Activates PCINT Interrupts from Pin 0 - 7 that are enabled in PCMSK */
	PCICR |= (1 << PCIE0);
 5d2:	e8 e6       	ldi	r30, 0x68	; 104
 5d4:	f0 e0       	ldi	r31, 0x00	; 0
 5d6:	80 81       	ld	r24, Z
 5d8:	81 60       	ori	r24, 0x01	; 1
 5da:	80 83       	st	Z, r24

	/* Activates Specific Interrupt */
	PCMSK0 |= (1 << PCINT1);
 5dc:	eb e6       	ldi	r30, 0x6B	; 107
 5de:	f0 e0       	ldi	r31, 0x00	; 0
 5e0:	80 81       	ld	r24, Z
 5e2:	82 60       	ori	r24, 0x02	; 2
 5e4:	80 83       	st	Z, r24
}
 5e6:	08 95       	ret

000005e8 <_exit>:
 5e8:	f8 94       	cli

000005ea <__stop_program>:
 5ea:	ff cf       	rjmp	.-2      	; 0x5ea <__stop_program>
